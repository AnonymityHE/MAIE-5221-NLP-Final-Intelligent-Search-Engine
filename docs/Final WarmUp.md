## **核心策略与技术栈**

- **核心策略**: 采用“最小可行产品（MVP）优先”的迭代开发模式，先保证核心流程通畅，再逐步完善。
- **技术栈**:
  - **后端**: Python, FastAPI
  - **AI核心**: LangChain, DeepSeek API
  - **向量数据库**: Milvus
  - **前端**: Next.js (React), shadcn/ui
  - **部署**: Docker, Docker Compose

------

## **项目执行阶段规划**

### **第一阶段：地基搭建与核心RAG流程贯通 (W4 - W6)**

🎯 目标:

此阶段的唯一目标是搭建一个可以实际操作的最小系统。它必须能完成：前端提问 -> 后端处理 -> Milvus检索 -> LLM生成 -> 前端展示 的完整闭环。

**✅ 关键任务分解**:

- **数据/运维工程师 (负责数据管道与Milvus)**:

  1. **部署与验证Milvus**:

     - 从Milvus官网获取Docker Compose的 `yml` 文件，在本地或服务器上启动Milvus服务。
     - 访问Milvus ATTU（其自带的Web UI）或使用Python SDK连接，确保服务正常运行。

  2. **创建数据集合 (Collection)**:

     - 在Milvus中设计并创建一个Collection，定义好向量字段（如 `vector`）和可能的元数据字段（如 `text`, `source_file`）。

  3. **编写数据注入脚本 (`ingestion.py`)**:

     - 使用 

       `PyMuPDF` 或 `python-docx` 库加载项目提供的文档 1。

     - 使用LangChain的 `RecursiveCharacterTextSplitter` 将文本切割成语义连贯的小块 (Chunks)。

     - 选择一个合适的开源Embedding模型（如 `sentence-transformers/all-MiniLM-L6-v2`），将文本块转换为向量。

     - 编写循环逻辑，将文本块原文和对应的向量批量插入到Milvus的Collection中。

  4. **封装检索函数 (`retriever.py`)**:

     - 编写一个独立的Python函数 `search(query_text)`。
     - 该函数接收一个问题字符串，将其向量化，然后调用Milvus的 `search()` API，返回最相似的Top-K个文本块。

- **后端/AI工程师 (负责API与AI逻辑)**:

  1. **搭建FastAPI项目**:
     - 创建清晰的项目结构，包含路由（routers）、模型（models）、服务（services）等目录。
     - 使用Pydantic定义好API的请求体（如 `QueryRequest`）和响应体（如 `QueryResponse`）。
  2. **实现核心RAG接口 (`/api/rag_query`)**:
     - 该接口接收前端传来的问题。
     - 调用数据工程师封装好的 `search()` 函数，从Milvus获取相关的上下文信息。
     - 设计一个精炼的Prompt模板，格式为：“基于以下信息：{上下文} \n\n请回答这个问题：{用户问题}”。
     - 调用DeepSeek API，将填充好的Prompt发送过去，获取生成的答案 2。
     - 将答案封装后返回给前端。
  3. **编写API文档**:
     - 利用FastAPI自动生成的Swagger UI (/docs)，与前端工程师明确接口的地址、请求方法、参数和返回值格式。

- **前端工程师 (负责用户界面)**:

  1. **初始化项目与UI组件**:
     - 使用 `create-next-app` 创建一个基于TypeScript的Next.js项目。
     - 通过CLI引入 `shadcn/ui` 的核心组件：`Input`, `Button`, `Card`, `ScrollArea`。
  2. **开发主搜索界面**:
     - 构建一个居中的、简洁的搜索页面，包含一个输入框和一个“搜索”按钮。
     - 下方预留一个区域，用于展示搜索结果。
  3. **实现API通信层**:
     - 建议使用 `axios` 或 `swr` 库来管理API请求。
     - 创建一个专门的 `apiService.ts` 文件，封装对后端 `/api/rag_query` 接口的调用逻辑。
     - 实现点击按钮后，获取输入框内容，调用API，并将返回的答案呈现在结果区的 `Card` 组件中。

🏆 阶段性成果:

一个功能虽简单但完整的问答系统。团队可以首次看到自己努力的成果，并建立后续开发的信心。

------

### **第二阶段：智能化扩展与能力增强 (W7 - W9)**

🎯 目标:

系统升级为智能代理 (Agent)，能够根据问题类型自主选择工具 ，并引入二次排序机制以提升结果准确性 。此阶段成果将用于中期报告。

**✅ 关键任务分解**:

- **后端/AI工程师**:

  1. **重构为Agent架构**:

     - 引入LangChain的Agents模块，选择一个合适的Agent类型（如 `ReAct`）。
     - 将第一阶段的RAG逻辑封装成一个自定义的`Tool`，名为 `LocalKnowledgeBaseTool`。

  2. **开发并集成新工具**:

     - **网页搜索工具**: 使用一个免费的搜索API（如SerpApi, SearchApi），将其封装成 `WebSearchTool`。

     - **领域API工具**: 至少实现一个领域智能工具 ，例如，调用免费天气API封装成 

       `WeatherTool`，可以回答关于天气的问题 。

  3. **实现智能路由与执行**:

     - 创建一个Agent Executor，并将上述所有工具注册给它。
     - 精心设计Agent的系统提示（System Prompt），引导它在面对不同问题时，能正确地思考并选择最合适的工具。
     - 改造API接口，现在它接收问题后，交由Agent Executor来处理，并返回Agent的最终答案和它使用的工具来源。

- **数据/运维工程师**:

  1. **实现二次排序 (Reranker)**:
     - 在 `retriever.py` 中，修改 `search` 函数。
     - 在从Milvus获取Top-20个结果后，使用一个Cross-Encoder模型（如 `bge-reranker-base`）计算每个结果与原始问题的精确相关性分数。
     - 根据新分数对这20个结果重新排序，并返回Top-5个最相关的作为最终上下文。
  2. **准备测试**:
     - 根据项目方发布的第一和第二个测试集，评估RAG和Agent的回答质量 。

- **前端工程师**:

  1. **升级状态管理**:
     - 使用 `useState` 或更复杂的状态管理库（如Zustand），来处理从后端返回的更复杂的数据结构（包含答案和来源）。
  2. **丰富结果展示**:
     - 在展示答案的 `Card` 组件上，增加一个小图标或标签，清晰地标明该答案的来源是“本地知识库”、“网页搜索”还是“天气查询”。

🏆 阶段性成果:

一个具备初步智能的搜索引擎。它不再是简单的“问-答”机器，而是能够“思考-规划-执行”的智能代理。

------

### **第三阶段：高级功能实现与全面优化 (W10 - W12)**

🎯 目标:

实现所有项目要求的高级功能，包括多模态输入 和动态工作流 ，并对系统的**速度**和**准确性**两大核心指标进行全面优化 。

**✅ 关键任务分解**:

- **后端/AI工程师**:
  1. **实现动态工作流**:
     - 针对项目描述中的复杂问题（如NVIDIA财报分析 11），通过多轮对话或更复杂的Prompt Engineering，引导Agent进行多步推理和工具链式调用。
     - 例如：Agent先用网页搜索找到财报，再用另一个工具提取关键数据，最后总结生成答案。
  2. **支持多模态输入**:
     - 创建一个新的API接口 `/api/multimodal_query`，使用FastAPI的 `UploadFile` 来接收用户上传的文件。
     - 后端接收文件后，对其进行临时的文本提取、切分和向量化，构建一个仅在此次会话中有效的“临时知识库”，并让Agent优先使用这个知识库进行问答。
- **数据/运维工程师**:
  1. **实现元数据过滤**:
     - 在向Milvus注入数据时，不仅存入向量，还存入来源、日期等元数据。
     - 修改检索函数，使其支持在向量搜索的同时进行元数据过滤（例如，`source = "finance_reports"`），以实现更精确的领域查询。
  2. **系统性能优化**:
     - 分析整个查询流程的耗时，找出瓶颈（是向量检索慢？还是LLM生成慢？）。
     - 根据瓶颈调整Milvus的索引参数（如`M`, `efConstruction`）或尝试更小的Reranker模型，在准确性和速度间找到最佳平衡。
- **前端工程师**:
  1. **开发文件上传UI**:
     - 使用 `react-dropzone` 或自定义组件，实现一个美观的文件拖拽上传区域。
     - 在文件上传和后端处理期间，显示明确的加载或处理中状态，防止用户困惑。
  2. **最终UI/UX打磨**:
     - 确保所有交互都流畅自然，界面在不同设备上都能良好显示。

🏆 阶段性成果:

一个功能完整、性能优良、符合所有核心要求的智能搜索引擎。

------

### **第四阶段：冲刺与交付 (W13)**

🎯 目标:

完成最终测试，准备好项目报告和演示，确保高质量交付。

**✅ 关键任务分解**:

- **全体成员**:

  1. **最终测试**:

     - 使用项目方提供的所有测试集对系统进行最后的、完整的评估。
     - 建立一个简单的表格，记录每个测试问题的回答准确性、答案来源和端到端耗时，作为最终报告的数据支撑。

  2. **Bug修复与代码文档**:

     - 集中修复所有在测试中发现的Bug。
     - 为核心函数和模块编写清晰的注释和文档字符串（Docstrings）。
     - 更新项目的 `README.md` 文件，包含项目介绍、技术栈、如何部署和运行的详细说明。

  3. **准备最终演示**:

     - 设计一个引人入胜的演示流程，至少包含：一个简单的RAG查询、一个需要Agent智能路由的查询、一个多步工作流的复杂查询，以及一个多模态文件问答的演示。

  4. **项目提交**:

     - 在截止日期前，打包好所有代码、文档和演示材料，进行最终提交 13。

       🏆 阶段性成果:

一份高质量、文档齐全、令人印象深刻的最终项目。